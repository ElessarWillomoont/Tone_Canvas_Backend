--- Project File Tree ---
[.]
  backend-dev.yaml
  Dockerfile
  flask_app.py
  requirements copy.txt
  requirements.txt
  [corpus]

--- Project File Tree with Content ---
[.]
  backend-dev.yaml
    --- File Content ---
    version: '3'
    services:
      backend-dev:
        build:
          context: .
        ports:
          - "5001:5000"
        volumes:
          - .:/app
        environment:
          - FLASK_ENV=development
          - FLASK_APP=flask_app.py
        command: ["flask", "run", "--host=0.0.0.0"]
    --- End of File ---
  Dockerfile
    --- File Content ---
    # Use an official Python runtime as a parent image
    FROM python:3.11-slim
    
    # Set the working directory in the container
    WORKDIR /app
    
    # Copy the current directory contents into the container at /app
    COPY . /app
    
    # Install any needed packages specified in requirements.txt
    RUN pip install --no-cache-dir -r requirements.txt
    
    # Make port 5000 available to the world outside this container
    EXPOSE 5000
    
    # Run the application
    CMD ["python", "flask_app.py"]
    --- End of File ---
  flask_app.py
    --- File Content ---
    from flask import Flask, send_from_directory, jsonify, request, send_file
    from flask_cors import CORS
    import os
    import numpy as np
    import matplotlib.pyplot as plt
    import soundfile as sf
    from scipy.interpolate import interp1d
    import json
    
    app = Flask(__name__)
    CORS(app)  # 启用CORS
    
    corpus_dir = os.path.join(os.path.dirname(__file__), 'corpus')
    icons_dir = os.path.join(os.path.dirname(__file__), 'icons')
    temp_dir = os.path.join(os.path.dirname(__file__), 'temp')
    
    if not os.path.exists(temp_dir):
        os.makedirs(temp_dir)
    
    files = [f for f in os.listdir(corpus_dir) if f.endswith('.wav')]
    current_index = 0
    
    @app.route('/api/get-wav-file', methods=['GET'])
    def get_wav_file():
        global current_index
        if not files:
            return "No wav files found", 404
    
        file_to_play = files[current_index]
        return send_from_directory(corpus_dir, file_to_play)
    
    @app.route('/api/switch-wav-file', methods=['POST'])
    def switch_wav_file():
        global current_index
        current_index = (current_index + 1) % len(files)
        return jsonify(currentIndex=current_index)
    
    @app.route('/api/get-icon/<filename>', methods=['GET'])
    def get_icon(filename):
        return send_from_directory(icons_dir, filename)
    
    @app.route('/api/get-pitch-json', methods=['GET'])
    def get_pitch_json():
        global current_index
        if not files:
            return "No wav files found", 404
    
        pitch_file = os.path.join(corpus_dir, files[current_index].replace('.wav', '.Pitch'))
        if not os.path.exists(pitch_file):
            return "No pitch file found for the current wav file", 404
    
        target_sample_rate = 100  # Desired sample rate for the output
        new_times, interpolated_frequencies = process_pitch_file(pitch_file, target_sample_rate)
    
        json_output_path = os.path.join(temp_dir, 'interpolated_pitch_data.json')
        save_interpolated_data_to_json(new_times, interpolated_frequencies, json_output_path)
        
        return send_file(json_output_path, as_attachment=True)
    
    @app.route('/api/get-pitch-audio', methods=['GET'])
    def get_pitch_audio():
        global current_index
        if not files:
            return "No wav files found", 404
    
        pitch_file = os.path.join(corpus_dir, files[current_index].replace('.wav', '.Pitch'))
        if not os.path.exists(pitch_file):
            return "No pitch file found for the current wav file", 404
    
        target_sample_rate = 44100  # Desired sample rate for the output
        new_times, interpolated_frequencies = process_pitch_file(pitch_file, target_sample_rate)
    
        sine_wave = generate_sine_wave(interpolated_frequencies, target_sample_rate)
        audio_output_path = os.path.join(temp_dir, 'pitch_only_audio_manually.wav')
        sf.write(audio_output_path, sine_wave, target_sample_rate)
        
        return send_file(audio_output_path, as_attachment=True)
    
    def parse_praat_pitch_file(file_path):
        with open(file_path, 'r', encoding='utf-8') as file:
            content = file.readlines()
    
        frames_data = []
        current_frame = None
        intensity = None
        x1, dx = None, None
    
        for line in content:
            line = line.strip()
            if line.startswith('x1 ='):
                x1 = float(line.split('=')[1].strip())
            elif line.startswith('dx ='):
                dx = float(line.split('=')[1].strip())
            elif line.startswith('frames [') and 'frames []' not in line:
                if current_frame is not None:
                    frames_data.append(current_frame)
                current_frame = {'frame': int(line.split('[')[1].split(']')[0]), 'candidates': []}
            elif line.startswith('intensity ='):
                intensity = float(line.split('=')[1].strip())
                current_frame['intensity'] = intensity
            elif line.startswith('candidates ['):
                candidate = {}
            elif line.startswith('frequency ='):
                candidate['frequency'] = float(line.split('=')[1].strip())
            elif line.startswith('strength ='):
                candidate['strength'] = float(line.split('=')[1].strip())
                current_frame['candidates'].append(candidate)
    
        if current_frame is not None:
            frames_data.append(current_frame)
        
        return frames_data, x1, dx
    
    def calculate_times(frames_data, x1, dx):
        return [x1 + (frame['frame'] - 1) * dx for frame in frames_data]
    
    def segment_nonzero_times_and_frequencies(times, frequencies):
        segments = []
        current_segment = {'times': [], 'frequencies': []}
        
        for time, frequency in zip(times, frequencies):
            if frequency > 0:
                current_segment['times'].append(time)
                current_segment['frequencies'].append(frequency)
            else:
                if current_segment['times']:
                    segments.append(current_segment)
                    current_segment = {'times': [], 'frequencies': []}
        
        if current_segment['times']:
            segments.append(current_segment)
        
        return segments
    
    def interpolate_pitch_segments(segments, target_sample_rate):
        all_new_times = []
        all_interpolated_frequencies = []
        
        for segment in segments:
            times = np.array(segment['times'])
            frequencies = np.array(segment['frequencies'])
            
            # Create an interpolation function
            interpolation_function = interp1d(times, frequencies, kind='cubic', fill_value="extrapolate")
            
            # Generate new time points at the target sample rate
            segment_new_times = np.arange(times[0], times[-1], 1/target_sample_rate)
            
            # Interpolate frequencies at the new time points
            segment_interpolated_frequencies = interpolation_function(segment_new_times)
            
            all_new_times.append(segment_new_times)
            all_interpolated_frequencies.append(segment_interpolated_frequencies)
        
        return all_new_times, all_interpolated_frequencies
    
    def generate_sine_wave(frequencies, sample_rate):
        frequencies = np.array(frequencies)  # Ensure frequencies is a NumPy array
        t = np.arange(len(frequencies)) / sample_rate
        phase = np.cumsum(2 * np.pi * frequencies / sample_rate)
        wave = np.sin(phase)
        return wave
    
    def process_pitch_file(file_path, target_sample_rate):
        frames_data, x1, dx = parse_praat_pitch_file(file_path)
        times = calculate_times(frames_data, x1, dx)
        primary_frequencies = [frame['candidates'][0]['frequency'] for frame in frames_data]
    
        segments = segment_nonzero_times_and_frequencies(times, primary_frequencies)
        all_new_times, all_interpolated_frequencies = interpolate_pitch_segments(segments, target_sample_rate)
        
        combined_times = []
        combined_frequencies = []
    
        previous_end_time = None
    
        for new_times, interpolated_frequencies in zip(all_new_times, all_interpolated_frequencies):
            if previous_end_time is not None and new_times[0] > previous_end_time:
                zero_times = np.arange(previous_end_time, new_times[0], 1/target_sample_rate)
                combined_times.extend(zero_times)
                combined_frequencies.extend(np.zeros_like(zero_times))
            
            combined_times.extend(new_times)
            combined_frequencies.extend(interpolated_frequencies)
            previous_end_time = new_times[-1]
        
        return np.array(combined_times), np.array(combined_frequencies)
    
    def save_interpolated_data_to_json(times, frequencies, file_path):
        # Special mark frequencies of 0 as NaN
        data = [{'time': t, 'frequency': float(f) if f != 0 else 'NaN'} for t, f in zip(times, frequencies)]
        
        # Calculate max and min of non-zero frequencies
        non_zero_frequencies = [f for f in frequencies if f > 0]
        max_frequency = max(non_zero_frequencies)
        min_frequency = min(non_zero_frequencies)
        
        json_data = {
            'max_frequency': max_frequency,
            'min_frequency': min_frequency,
            'data': data
        }
        
        with open(file_path, 'w') as json_file:
            json.dump(json_data, json_file, indent=4)
    
    if __name__ == '__main__':
        app.run(debug=True, host='0.0.0.0', port=5000)
    --- End of File ---
  requirements copy.txt
    --- File Content ---
    flask
    flask-cors
    anyio==4.4.0
    argon2-cffi==23.1.0
    argon2-cffi-bindings==21.2.0
    arrow==1.3.0
    asttokens==2.4.1
    async-lru==2.0.4
    attrs==23.2.0
    Babel==2.15.0
    beautifulsoup4==4.12.3
    bleach==6.1.0
    certifi==2024.7.4
    cffi==1.16.0
    charset-normalizer==3.3.2
    comm==0.2.2
    contourpy==1.2.1
    cycler==0.12.1
    debugpy==1.8.2
    decorator==5.1.1
    defusedxml==0.7.1
    executing==2.0.1
    fastjsonschema==2.20.0
    fonttools==4.53.1
    fqdn==1.5.1
    h11==0.14.0
    httpcore==1.0.5
    httpx==0.27.0
    idna==3.7
    ipykernel==6.29.5
    ipython==8.26.0
    ipywidgets==8.1.3
    isoduration==20.11.0
    jedi==0.19.1
    Jinja2==3.1.4
    json5==0.9.25
    jsonpointer==3.0.0
    jsonschema==4.23.0
    jsonschema-specifications==2023.12.1
    jupyter==1.0.0
    jupyter-console==6.6.3
    jupyter-events==0.10.0
    jupyter-lsp==2.2.5
    jupyter_client==8.6.2
    jupyter_core==5.7.2
    jupyter_server==2.14.1
    jupyter_server_terminals==0.5.3
    jupyterlab==4.2.3
    jupyterlab_pygments==0.3.0
    jupyterlab_server==2.27.2
    jupyterlab_widgets==3.0.11
    kiwisolver==1.4.5
    MarkupSafe==2.1.5
    matplotlib==3.9.1
    matplotlib-inline==0.1.7
    mistune==3.0.2
    nbclient==0.10.0
    nbconvert==7.16.4
    nbformat==5.10.4
    nest-asyncio==1.6.0
    notebook==7.2.1
    notebook_shim==0.2.4
    numpy==2.0.0
    overrides==7.7.0
    packaging==24.1
    pandas==2.2.2
    pandocfilters==1.5.1
    parso==0.8.4
    pexpect==4.9.0
    pillow==10.4.0
    platformdirs==4.2.2
    praat-parselmouth==0.4.3
    prometheus_client==0.20.0
    prompt_toolkit==3.0.47
    psutil==6.0.0
    ptyprocess==0.7.0
    pure-eval==0.2.2
    pycparser==2.22
    Pygments==2.18.0
    pyparsing==3.1.2
    python-dateutil==2.9.0.post0
    python-json-logger==2.0.7
    pytz==2024.1
    PyYAML==6.0.1
    pyzmq==26.0.3
    qtconsole==5.5.2
    QtPy==2.4.1
    referencing==0.35.1
    requests==2.32.3
    rfc3339-validator==0.1.4
    rfc3986-validator==0.1.1
    rpds-py==0.19.0
    scipy==1.14.0
    seaborn==0.13.2
    Send2Trash==1.8.3
    six==1.16.0
    sniffio==1.3.1
    soundfile==0.12.1
    soupsieve==2.5
    stack-data==0.6.3
    terminado==0.18.1
    TextGrid==1.6.1
    tgt==1.5
    tinycss2==1.3.0
    tornado==6.4.1
    traitlets==5.14.3
    types-python-dateutil==2.9.0.20240316
    typing_extensions==4.12.2
    tzdata==2024.1
    uri-template==1.3.0
    urllib3==2.2.2
    wcwidth==0.2.13
    webcolors==24.6.0
    webencodings==0.5.1
    websocket-client==1.8.0
    widgetsnbextension==4.0.11
    --- End of File ---
  requirements.txt
    --- File Content ---
    flask
    flask-cors
    numpy==2.0.0
    matplotlib==3.9.1
    soundfile==0.12.1
    scipy==1.14.0
    --- End of File ---
  [corpus]